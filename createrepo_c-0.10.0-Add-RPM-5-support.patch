From 36fe9483091626da445ce3b349b93f74e2924d7b Mon Sep 17 00:00:00 2001
From: Jeff Johnson <jbj@rpm5.org>
Date: Thu, 1 Dec 2016 11:50:33 -0500
Subject: [PATCH] Add RPM 5 support

---
 CMakeLists.txt          |  13 ++
 src/CMakeLists.txt      |   4 +-
 src/createrepo_shared.c |   6 +
 src/deltarpms.h.in      |   4 +
 src/dumper_thread.h     |   4 +
 src/misc.c              |   8 +-
 src/parsehdr.c          | 421 +++++++++++++++++++++++++++++++++++++++++++++++-
 src/parsehdr.h          |   7 +
 src/parsepkg.c          |  29 +++-
 src/sqlite.c            |   2 +
 10 files changed, 487 insertions(+), 11 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index c4f06f8..9161c3e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -41,6 +41,17 @@ include_directories(${GLIB2_INCLUDE_DIRS})
 include_directories(${LIBXML2_INCLUDE_DIR})
 
 
+IF (RPM5)
+
+    MESSAGE (STATUS "Enabling RPM 5 support")
+    ADD_DEFINITIONS (-DRPM5)
+    FIND_PACKAGE (PkgConfig REQUIRED)
+    PKG_CHECK_MODULES (RPM REQUIRED rpm)
+    INCLUDE_DIRECTORIES (${RPM_INCLUDE_DIRS})
+    SET(RPMDB_LIBRARY ${RPM_LIBRARY_DIRS})
+
+ELSE (RPM5)
+
 IF (RPM_PATH)
     SET (RPM_PATH "/home/tmlcoch/git/rpm")
     include_directories("${RPM_PATH}/include/")
@@ -69,6 +80,8 @@ ELSE (RPM_PATH)
     message("Using system RPM: ${RPMDB_LIBRARY}")
 ENDIF (RPM_PATH)
 
+ENDIF (RPM5)
+
 # drpm
 if (DRPM_PATH)
     include_directories (${DRPM_PATH}/)
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 33ac9c8..4fe2f10 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -60,12 +60,12 @@ ADD_LIBRARY(libcreaterepo_c SHARED ${createrepo_c_SRCS})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${BZIP2_LIBRARIES})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${CURL_LIBRARY})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${EXPAT_LIBRARIES})
-TARGET_LINK_LIBRARIES(libcreaterepo_c ${GLIB2_LIBRARIES})
+TARGET_LINK_LIBRARIES(libcreaterepo_c ${GLIB2_LDFLAGS})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${Libmagic_LIBRARY})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${LIBXML2_LIBRARIES})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${LZMA_LIBRARIES})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${OPENSSL_LIBRARIES})
-TARGET_LINK_LIBRARIES(libcreaterepo_c ${RPMDB_LIBRARY})
+TARGET_LINK_LIBRARIES(libcreaterepo_c ${RPM_LDFLAGS})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${SQLITE3_LIBRARIES})
 TARGET_LINK_LIBRARIES(libcreaterepo_c ${ZLIB_LIBRARY})
 IF (DRPM_LIBRARY)
diff --git a/src/createrepo_shared.c b/src/createrepo_shared.c
index 5872029..3d7c57e 100644
--- a/src/createrepo_shared.c
+++ b/src/createrepo_shared.c
@@ -104,7 +104,9 @@ cr_set_cleanup_handler(const char *lock_dir,
     sigaction(SIGUSR2, &sigact, NULL);
 
     // Handle signals that terminate (from the POSIX.1-2001)
+#ifdef	SIGPOLL
     sigaction(SIGPOLL, &sigact, NULL);
+#endif
     sigaction(SIGPROF, &sigact, NULL);
     sigaction(SIGVTALRM, &sigact, NULL);
 
@@ -137,7 +139,9 @@ cr_block_terminating_signals(GError **err)
     sigaddset(&intmask, SIGTERM);
     sigaddset(&intmask, SIGUSR1);
     sigaddset(&intmask, SIGUSR2);
+#ifdef	SIGPOLL
     sigaddset(&intmask, SIGPOLL);
+#endif
     sigaddset(&intmask, SIGPROF);
     sigaddset(&intmask, SIGVTALRM);
 
@@ -165,7 +169,9 @@ cr_unblock_terminating_signals(GError **err)
     sigaddset(&intmask, SIGTERM);
     sigaddset(&intmask, SIGUSR1);
     sigaddset(&intmask, SIGUSR2);
+#ifdef	SIGPOLL
     sigaddset(&intmask, SIGPOLL);
+#endif
     sigaddset(&intmask, SIGPROF);
     sigaddset(&intmask, SIGVTALRM);
 
diff --git a/src/deltarpms.h.in b/src/deltarpms.h.in
index 3a9f9f5..7e582f5 100644
--- a/src/deltarpms.h.in
+++ b/src/deltarpms.h.in
@@ -25,7 +25,11 @@ extern "C" {
 #endif
 
 #include <glib.h>
+
+#ifndef	RPM5
 #include <rpm/rpmlib.h>
+#endif	/* RPM5*/
+
 #include "package.h"
 #include "parsehdr.h"
 #include "xml_file.h"
diff --git a/src/dumper_thread.h b/src/dumper_thread.h
index e1ae715..d409c9f 100644
--- a/src/dumper_thread.h
+++ b/src/dumper_thread.h
@@ -25,7 +25,11 @@ extern "C" {
 #endif
 
 #include <glib.h>
+
+#ifndef	RPM5
 #include <rpm/rpmlib.h>
+#endif	/* RPM5 */
+
 #include "load_metadata.h"
 #include "locate_metadata.h"
 #include "misc.h"
diff --git a/src/misc.c b/src/misc.c
index ed05827..6ca0741 100644
--- a/src/misc.c
+++ b/src/misc.c
@@ -26,7 +26,13 @@
 #include <curl/curl.h>
 #include <errno.h>
 #include <ftw.h>
+
+#ifdef	RPM5
+#include <rpmevr.h>
+#else	/* RPM5 */
 #include <rpm/rpmlib.h>
+#endif	/* RPM5 */
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -1366,7 +1372,7 @@ cr_append_pid_and_datetime(const char *str, const char *suffix)
                                     str ? str : "",
                                     (intmax_t) getpid(),
                                     datetime,
-                                    tv.tv_usec,
+                                    (long)tv.tv_usec,
                                     suffix ? suffix : "");
     return result;
 }
diff --git a/src/parsehdr.c b/src/parsehdr.c
index 2f6a79e..4a33c3f 100644
--- a/src/parsehdr.c
+++ b/src/parsehdr.c
@@ -19,9 +19,21 @@
 
 #include <glib.h>
 #include <assert.h>
-#include <rpm/rpmfi.h>
 #include <stdlib.h>
 #include "parsehdr.h"
+
+#ifdef	RPM5
+#include <sys/stat.h>
+#define	_RPMEVR_INTERNAL
+#include <rpmevr.h>
+#warning FIXME: expose RPMSENSE_SCRIPT_PRE/POST
+#define	RPMSENSE_SCRIPT_PRE	(1 << 9)
+#define RPMSENSE_SCRIPT_POST	(1 << 10)
+#include <rpmfi.h>
+#else	/* RPM5 */
+#include <rpm/rpmfi.h>
+#endif	/* RPM5 */
+
 #include "xml_dump.h"
 #include "misc.h"
 #include "cleanup.h"
@@ -65,6 +77,36 @@ static DepItem dep_items[] = {
     { DEP_SENTINEL, 0, 0, 0 },
 };
 
+#ifdef	RPM5
+static
+const char * headerGetString(Header h, rpmTag tag)
+{
+    const char * res = NULL;
+    HE_t he = (HE_t) memset(alloca(sizeof(*he)), 0, sizeof(*he));
+    he->tag = tag;
+    if (headerGet(h, he, 0) && he->t == RPM_STRING_TYPE) {
+	res = he->p.str;
+	he->p.ptr = NULL;
+    }
+    if (he->p.ptr)
+	free(he->p.ptr);
+    return (res ? res : strdup(""));
+}
+
+static
+uint64_t headerGetNumber(Header h, rpmTag tag)
+{
+    uint64_t res = 0;
+    HE_t he = (HE_t) memset(alloca(sizeof(*he)), 0, sizeof(*he));
+    he->tag = tag;
+    if (headerGet(h, he, 0) && he->t == RPM_UINT32_TYPE)
+	res = he->p.ui32p[0];
+    if (he->p.ptr)
+	free(he->p.ptr);
+    return res;
+}
+#endif	/* RPM5 */
+
 static inline int
 cr_compare_dependency(const char *dep1, const char *dep2)
 {
@@ -160,8 +202,10 @@ cr_package_from_header(Header hdr,
 
     // Create rpm tag data container
 
+#ifndef	RPM5
     rpmtd td = rpmtdNew();
     headerGetFlags flags = HEADERGET_MINMEM | HEADERGET_EXT;
+#endif
 
 
     // Fill package structure
@@ -188,15 +232,26 @@ cr_package_from_header(Header hdr,
     pkg->summary = cr_safe_string_chunk_insert(pkg->chunk, headerGetString(hdr, RPMTAG_SUMMARY));
     pkg->description = cr_safe_string_chunk_insert_null(pkg->chunk, headerGetString(hdr, RPMTAG_DESCRIPTION));
     pkg->url = cr_safe_string_chunk_insert(pkg->chunk, headerGetString(hdr, RPMTAG_URL));
+
+#ifdef	RPM5
+    pkg->time_build = headerGetNumber(hdr, RPMTAG_BUILDTIME);
+#else	/* RPM5 */
     if (headerGet(hdr, RPMTAG_BUILDTIME, td, flags)) {
         pkg->time_build = rpmtdGetNumber(td);
     }
+#endif	/* RPM5 */
+
     pkg->rpm_license = cr_safe_string_chunk_insert(pkg->chunk, headerGetString(hdr, RPMTAG_LICENSE));
     pkg->rpm_vendor = cr_safe_string_chunk_insert(pkg->chunk, headerGetString(hdr, RPMTAG_VENDOR));
     pkg->rpm_group = cr_safe_string_chunk_insert(pkg->chunk, headerGetString(hdr, RPMTAG_GROUP));
     pkg->rpm_buildhost = cr_safe_string_chunk_insert(pkg->chunk, headerGetString(hdr, RPMTAG_BUILDHOST));
     pkg->rpm_sourcerpm = cr_safe_string_chunk_insert(pkg->chunk, headerGetString(hdr, RPMTAG_SOURCERPM));
     pkg->rpm_packager = cr_safe_string_chunk_insert(pkg->chunk, headerGetString(hdr, RPMTAG_PACKAGER));
+
+#ifdef	RPM5
+    pkg->size_installed = headerGetNumber(hdr, RPMTAG_SIZE);
+    pkg->size_archive = headerGetNumber(hdr, RPMTAG_ARCHIVESIZE);
+#else	/* RPM5 */
     if (headerGet(hdr, RPMTAG_SIZE, td, flags)) {
         pkg->size_installed = rpmtdGetNumber(td);
     }
@@ -206,20 +261,97 @@ cr_package_from_header(Header hdr,
 
     rpmtdFreeData(td);
     rpmtdFree(td);
-
+#endif	/* RPM5 */
 
     //
     // Fill files
     //
 
+    GHashTable *filenames_hashtable = g_hash_table_new(g_str_hash, g_str_equal);
+
+#ifdef	RPM5
+
+    HE_t FILENAMEShe = (HE_t) memset(alloca(sizeof(*FILENAMEShe)), 0, sizeof(*FILENAMEShe));
+    FILENAMEShe->tag = RPMTAG_FILEPATHS;
+
+    HE_t DIRINDEXEShe = (HE_t) memset(alloca(sizeof(*DIRINDEXEShe)), 0, sizeof(*DIRINDEXEShe));
+    DIRINDEXEShe->tag = RPMTAG_DIRINDEXES;
+
+    HE_t BASENAMEShe = (HE_t) memset(alloca(sizeof(*BASENAMEShe)), 0, sizeof(*BASENAMEShe));
+    BASENAMEShe->tag = RPMTAG_BASENAMES;
+
+    HE_t FILEFLAGShe = (HE_t) memset(alloca(sizeof(*FILEFLAGShe)), 0, sizeof(*FILEFLAGShe));
+    FILEFLAGShe->tag = RPMTAG_FILEFLAGS;
+
+    HE_t FILEMODEShe = (HE_t) memset(alloca(sizeof(*FILEMODEShe)), 0, sizeof(*FILEMODEShe));
+    FILEMODEShe->tag = RPMTAG_FILEMODES;
+
+    HE_t DIRNAMEShe = (HE_t) memset(alloca(sizeof(*DIRNAMEShe)), 0, sizeof(*DIRNAMEShe));
+    DIRNAMEShe->tag = RPMTAG_DIRNAMES;
+
+    // Create list of pointer to directory names
+
+    int dir_count;
+    char ** dir_list = NULL;
+    if (headerGet(hdr, DIRNAMEShe, 0)) {
+	dir_count = DIRNAMEShe->c;
+        dir_list = malloc(sizeof(char *) * dir_count);
+	for (unsigned x = 0; x < dir_count; x++) {
+	    const char * dn = DIRNAMEShe->p.argv[x];
+            dir_list[x] = cr_safe_string_chunk_insert(pkg->chunk, dn);
+        }
+    }
+
+    if (headerGet(hdr, FILENAMEShe,  0) &&
+        headerGet(hdr, DIRINDEXEShe, 0) &&
+        headerGet(hdr, BASENAMEShe,  0) &&
+        headerGet(hdr, FILEFLAGShe,  0) &&
+        headerGet(hdr, FILEMODEShe,  0))
+    {
+	for (unsigned x = 0; x < BASENAMEShe->c; x++) {
+
+            cr_PackageFile *packagefile = cr_package_file_new();
+            packagefile->name = cr_safe_string_chunk_insert(pkg->chunk,
+                                                        BASENAMEShe->p.argv[x]);
+            packagefile->path = (dir_list) ? dir_list[(int) DIRINDEXEShe->p.ui32p[x] ] : "";
+
+            if (S_ISDIR(FILEMODEShe->p.ui16p[x])) {
+                // Directory
+                packagefile->type = cr_safe_string_chunk_insert(pkg->chunk, "dir");
+            } else if (FILEFLAGShe->p.ui32p[x] & RPMFILE_GHOST) {
+                // Ghost
+                packagefile->type = cr_safe_string_chunk_insert(pkg->chunk, "ghost");
+            } else {
+                // Regular file
+                packagefile->type = cr_safe_string_chunk_insert(pkg->chunk, "");
+            }
+
+            g_hash_table_replace(filenames_hashtable,
+                                 (gpointer) FILENAMEShe->p.argv[x],
+                                 (gpointer) FILENAMEShe->p.argv[x]);
+            pkg->files = g_slist_prepend(pkg->files, packagefile);
+        }
+        pkg->files = g_slist_reverse (pkg->files);
+    }
+
+    if (DIRNAMEShe->p.ptr) free(DIRNAMEShe->p.ptr);
+    if (DIRINDEXEShe->p.ptr) free(DIRINDEXEShe->p.ptr);
+    if (BASENAMEShe->p.ptr) free(BASENAMEShe->p.ptr);
+    if (FILEFLAGShe->p.ptr) free(FILEFLAGShe->p.ptr);
+    if (FILEMODEShe->p.ptr) free(FILEMODEShe->p.ptr);
+
+    if (dir_list) {
+        free((void *) dir_list);
+    }
+
+#else	/* RPM5 */
+
     rpmtd full_filenames = rpmtdNew(); // Only for filenames_hashtable
     rpmtd indexes   = rpmtdNew();
     rpmtd filenames = rpmtdNew();
     rpmtd fileflags = rpmtdNew();
     rpmtd filemodes = rpmtdNew();
 
-    GHashTable *filenames_hashtable = g_hash_table_new(g_str_hash, g_str_equal);
-
     rpmtd dirnames = rpmtdNew();
 
 
@@ -291,14 +423,13 @@ cr_package_from_header(Header hdr,
     if (dir_list) {
         free((void *) dir_list);
     }
+#endif	/* RPM5 */
 
 
     //
     // PCOR (provides, conflicts, obsoletes, requires)
     //
 
-    rpmtd fileversions = rpmtdNew();
-
     // Struct used as value in ap_hashtable
     struct ap_value_struct {
         const char *flags;
@@ -315,6 +446,192 @@ cr_package_from_header(Header hdr,
                                                      NULL,
                                                      free);
 
+#ifdef	RPM5
+
+    HE_t Nhe = (HE_t) memset(alloca(sizeof(*Nhe)), 0, sizeof(*Nhe));
+    HE_t Fhe = (HE_t) memset(alloca(sizeof(*Fhe)), 0, sizeof(*Fhe));
+    HE_t EVRhe = (HE_t) memset(alloca(sizeof(*EVRhe)), 0, sizeof(*EVRhe));
+
+    for (int deptype=0; dep_items[deptype].type != DEP_SENTINEL; deptype++) {
+	Nhe->tag = dep_items[deptype].nametag;
+	Fhe->tag = dep_items[deptype].flagstag;
+	EVRhe->tag = dep_items[deptype].versiontag;
+        if (headerGet(hdr, Nhe, 0) &&
+            headerGet(hdr, Fhe, 0) &&
+            headerGet(hdr, EVRhe, 0))
+        {
+            // Because we have to select only libc.so with highest version
+            // e.g. libc.so.6(GLIBC_2.4)
+            cr_Dependency *libc_require_highest = NULL;
+
+	    for (unsigned x = 0; x < Nhe->c; x++) {
+                int pre = 0;
+                const char *filename = Nhe->p.argv[x];
+                guint64 num_flags = Fhe->p.ui32p[x];
+                const char *flags = cr_flag_to_str(num_flags);
+                const char *full_version = EVRhe->p.argv[x];
+
+                // Requires specific stuff
+                if (deptype == DEP_REQUIRES) {
+                    // Skip requires which start with "rpmlib("
+                    if (!strncmp("rpmlib(", filename, 7)) {
+                        continue;
+                    }
+
+                    // Skip package primary files
+                    if (g_hash_table_lookup_extended(filenames_hashtable, filename, NULL, NULL)) {
+                        if (cr_is_primary(filename)) {
+                            continue;
+                        }
+                    }
+
+                    // Skip files which are provided
+                    if (g_hash_table_lookup_extended(provided_hashtable, filename, NULL, NULL)) {
+                        continue;
+                    }
+
+                    // Calculate pre value
+                    if (num_flags & (RPMSENSE_PREREQ |
+                                     RPMSENSE_SCRIPT_PRE |
+                                     RPMSENSE_SCRIPT_POST))
+                    {
+                        pre = 1;
+                    }
+
+                    // Skip duplicate files
+                    gpointer value;
+                    if (g_hash_table_lookup_extended(ap_hashtable, filename, NULL, &value)) {
+                        struct ap_value_struct *ap_value = value;
+                        if (!g_strcmp0(ap_value->flags, flags) &&
+                            !strcmp(ap_value->version, full_version) &&
+                            (ap_value->pre == pre))
+                        {
+                            continue;
+                        }
+                    }
+                }
+
+                // Parse dep string
+                cr_EVR *evr = cr_str_to_evr(full_version, pkg->chunk);
+                if ((full_version && *full_version) && !evr->epoch) {
+                    // NULL in epoch mean that the epoch was bad (non-numerical)
+                    _cleanup_free_ gchar *pkg_nevra = cr_package_nevra(pkg);
+                    g_warning("Bad epoch in version string \"%s\" for dependency \"%s\" in package \"%s\"",
+                              full_version, filename, pkg_nevra);
+                    g_warning("Skipping this dependency");
+                    g_free(evr);
+                    continue;
+                }
+
+                // Create dynamic dependency object
+                cr_Dependency *dependency = cr_dependency_new();
+                dependency->name = cr_safe_string_chunk_insert(pkg->chunk, filename);
+                dependency->flags = cr_safe_string_chunk_insert(pkg->chunk, flags);
+                dependency->epoch = evr->epoch;
+                dependency->version = evr->version;
+                dependency->release = evr->release;
+                g_free(evr);
+
+                switch (deptype) {
+                    case DEP_PROVIDES:
+                        g_hash_table_replace(provided_hashtable, dependency->name, dependency->name);
+                        pkg->provides = g_slist_prepend(pkg->provides, dependency);
+                        break;
+                    case DEP_CONFLICTS:
+                        pkg->conflicts = g_slist_prepend(pkg->conflicts, dependency);
+                        break;
+                    case DEP_OBSOLETES:
+                        pkg->obsoletes = g_slist_prepend(pkg->obsoletes, dependency);
+                        break;
+                    case DEP_REQUIRES:
+                        dependency->pre = pre;
+
+                        // XXX: libc.so filtering ////////////////////////////
+                        if (g_str_has_prefix(dependency->name, "libc.so.6")) {
+                            if (!libc_require_highest)
+                                libc_require_highest = dependency;
+                            else {
+                                if (cr_compare_dependency(libc_require_highest->name,
+                                                       dependency->name) == 2)
+                                {
+                                    g_free(libc_require_highest);
+                                    libc_require_highest = dependency;
+                                } else
+                                    g_free(dependency);
+                            }
+                            break;
+                        }
+                        // XXX: libc.so filtering - END ///////////////////////
+
+                        pkg->requires = g_slist_prepend(pkg->requires, dependency);
+
+                        // Add file into ap_hashtable
+                        struct ap_value_struct *value = malloc(sizeof(struct ap_value_struct));
+                        value->flags = flags;
+                        value->version = full_version;
+                        value->pre = dependency->pre;
+                        g_hash_table_replace(ap_hashtable, dependency->name, value);
+                        break; //case REQUIRES end
+                    case DEP_SUGGESTS:
+                        pkg->suggests = g_slist_prepend(pkg->suggests, dependency);
+                        break;
+                    case DEP_ENHANCES:
+                        pkg->enhances = g_slist_prepend(pkg->enhances, dependency);
+                        break;
+                    case DEP_RECOMMENDS:
+                        pkg->recommends = g_slist_prepend(pkg->recommends, dependency);
+                        break;
+                    case DEP_SUPPLEMENTS:
+                        pkg->supplements = g_slist_prepend(pkg->supplements, dependency);
+                        break;
+#ifdef ENABLE_LEGACY_WEAKDEPS
+                    case DEP_OLDSUGGESTS:
+                        if ( num_flags & RPMSENSE_STRONG ) {
+                            pkg->recommends = g_slist_prepend(pkg->recommends, dependency);
+                        } else {
+                            pkg->suggests = g_slist_prepend(pkg->suggests, dependency);
+                        }
+                        break;
+                    case DEP_OLDENHANCES:
+                        if ( num_flags & RPMSENSE_STRONG ) {
+                            pkg->supplements = g_slist_prepend(pkg->supplements, dependency);
+                        } else {
+                            pkg->enhances = g_slist_prepend(pkg->enhances, dependency);
+                        }
+                        break;
+#endif
+                } // Switch end
+	    }	// For items end
+        }
+
+        if (Nhe->p.ptr) free(Nhe->p.ptr);
+        if (Fhe->p.ptr) free(Fhe->p.ptr);
+        if (EVRhe->p.ptr) free(EVRhe->p.ptr);
+    }
+
+    pkg->provides    = g_slist_reverse (pkg->provides);
+    pkg->conflicts   = g_slist_reverse (pkg->conflicts);
+    pkg->obsoletes   = g_slist_reverse (pkg->obsoletes);
+    pkg->requires    = g_slist_reverse (pkg->requires);
+    pkg->suggests    = g_slist_reverse (pkg->suggests);
+    pkg->enhances    = g_slist_reverse (pkg->enhances);
+    pkg->recommends  = g_slist_reverse (pkg->recommends);
+    pkg->supplements = g_slist_reverse (pkg->supplements);
+
+    g_hash_table_remove_all(filenames_hashtable);
+    g_hash_table_remove_all(provided_hashtable);
+    g_hash_table_remove_all(ap_hashtable);
+
+    g_hash_table_unref(filenames_hashtable);
+    g_hash_table_unref(provided_hashtable);
+    g_hash_table_unref(ap_hashtable);
+
+    if (FILENAMEShe->p.ptr) free(FILENAMEShe->p.ptr);
+
+#else	/* RPM5 */
+
+    rpmtd fileversions = rpmtdNew();
+
     for (int deptype=0; dep_items[deptype].type != DEP_SENTINEL; deptype++) {
         if (headerGet(hdr, dep_items[deptype].nametag, filenames, flags) &&
             headerGet(hdr, dep_items[deptype].flagstag, fileflags, flags) &&
@@ -488,12 +805,79 @@ cr_package_from_header(Header hdr,
 
     rpmtdFreeData(full_filenames);
     rpmtdFree(full_filenames);
+#endif	/* RPM5 */
 
 
     //
     // Changelogs
     //
 
+#ifdef	RPM5
+
+    HE_t TIMEhe = (HE_t) memset(alloca(sizeof(*TIMEhe)), 0, sizeof(*TIMEhe));
+    HE_t NAMEhe = (HE_t) memset(alloca(sizeof(*NAMEhe)), 0, sizeof(*NAMEhe));
+    HE_t TEXThe = (HE_t) memset(alloca(sizeof(*TEXThe)), 0, sizeof(*TEXThe));
+    TIMEhe->tag = RPMTAG_CHANGELOGTIME;
+    NAMEhe->tag = RPMTAG_CHANGELOGNAME;
+    TEXThe->tag = RPMTAG_CHANGELOGTEXT;
+
+    if (headerGet(hdr, TIMEhe, 0) &&
+        headerGet(hdr, NAMEhe, 0) &&
+        headerGet(hdr, TEXThe, 0))
+    {
+        gint64 last_time = G_GINT64_CONSTANT(0);
+	for (uint32_t ix = 0; ix < TIMEhe->c; ix++)
+	{
+            gint64 time = TIMEhe->p.ui32p[ix];
+
+            if (!(changelog_limit > 0 || changelog_limit == -1))
+                break;
+
+            cr_ChangelogEntry *changelog = cr_changelog_entry_new();
+            changelog->author    = cr_safe_string_chunk_insert(pkg->chunk,
+                                           NAMEhe->p.argv[ix]);
+            changelog->date      = time;
+            changelog->changelog = cr_safe_string_chunk_insert(pkg->chunk,
+                                            TEXThe->p.argv[ix]);
+
+            // Remove space from end of author name
+            if (changelog->author) {
+                size_t len, x;
+                len = strlen(changelog->author);
+                for (x=(len-1); x > 0; x--) {
+                    if (changelog->author[x] == ' ') {
+                        changelog->author[x] = '\0';
+                    } else {
+                        break;
+                    }
+                }
+            }
+
+            pkg->changelogs = g_slist_prepend(pkg->changelogs, changelog);
+            if (changelog_limit != -1)
+                changelog_limit--;
+
+            // If a previous entry has the same time, increment time of the previous
+            // entry by one. Ugly but works!
+            if (last_time == time) {
+                int tmp_time = time;
+                GSList *previous = pkg->changelogs;
+                while ((previous = g_slist_next(previous)) != NULL &&
+                       ((cr_ChangelogEntry *) (previous->data))->date == tmp_time) {
+                    ((cr_ChangelogEntry *) (previous->data))->date++;
+                    tmp_time++;
+                }
+            } else {
+                last_time = time;
+            }
+	}
+    }
+    if (TIMEhe->p.ptr) free(TIMEhe->p.ptr);
+    if (NAMEhe->p.ptr) free(NAMEhe->p.ptr);
+    if (TEXThe->p.ptr) free(TEXThe->p.ptr);
+
+#else	/* RPM5 */
+
     rpmtd changelogtimes = rpmtdNew();
     rpmtd changelognames = rpmtdNew();
     rpmtd changelogtexts = rpmtdNew();
@@ -564,6 +948,8 @@ cr_package_from_header(Header hdr,
     rpmtdFree(changelognames);
     rpmtdFree(changelogtexts);
 
+#endif	/* RPM5 */
+
 
     //
     // Keys and hdrid (data used for caching when the --cachedir is specified)
@@ -574,6 +960,28 @@ cr_package_from_header(Header hdr,
                                                  headerGetString(hdr, RPMTAG_HDRID));
 
     if (hdrrflags & CR_HDRR_LOADSIGNATURES) {
+#ifdef	RPM5
+        HE_t he = (HE_t) memset(alloca(sizeof(*he)), 0, sizeof(*he));
+        he->tag = RPMTAG_SIGGPG;
+        if (headerGet(hdr, he, 0) && he->t == RPM_BIN_TYPE && he->c > 0) {
+            pkg->siggpg = cr_binary_data_new();
+            pkg->siggpg->size = he->c;
+            pkg->siggpg->data = g_string_chunk_insert_len(pkg->chunk,
+                                                          he->p.ptr,
+                                                          he->c);
+        }
+        if (he->p.ptr) free(he->p.ptr);
+
+        he->tag = RPMTAG_SIGPGP;
+        if (headerGet(hdr, he, 0) && he->t == RPM_BIN_TYPE && he->c > 0) {
+            pkg->sigpgp = cr_binary_data_new();
+            pkg->sigpgp->size = he->c;
+            pkg->sigpgp->data = g_string_chunk_insert_len(pkg->chunk,
+                                                          he->p.ptr,
+                                                          he->c);
+        }
+        if (he->p.ptr) free(he->p.ptr);
+#else	/* RPM5 */
         rpmtd gpgtd = rpmtdNew();
         rpmtd pgptd = rpmtdNew();
 
@@ -599,6 +1007,7 @@ cr_package_from_header(Header hdr,
 
         rpmtdFree(gpgtd);
         rpmtdFree(pgptd);
+#endif	/* RPM5 */
     }
 
     return pkg;
diff --git a/src/parsehdr.h b/src/parsehdr.h
index 032acca..ac0f262 100644
--- a/src/parsehdr.h
+++ b/src/parsehdr.h
@@ -25,7 +25,14 @@ extern "C" {
 #endif
 
 #include <glib.h>
+
+#ifdef  RPM5
+#include <rpmtag.h>
+#include <rpmevr.h>
+#else   /* RPM5 */
 #include <rpm/rpmlib.h>
+#endif   /* RPM5 */
+
 #include "package.h"
 
 /** \defgroup   parsehdr         Header parser API.
diff --git a/src/parsepkg.c b/src/parsepkg.c
index f6038bd..3f333b5 100644
--- a/src/parsepkg.c
+++ b/src/parsepkg.c
@@ -24,13 +24,38 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
+
+#include "error.h"
+#include "parsehdr.h"
+
+#ifdef	RPM5
+#include <rpmio.h>
+#include <rpmmacro.h>
+#include <pkgio.h>
+#include <rpmfi.h>
+#include <rpmts.h>
+#define _RPMVSF_NODIGESTS       \
+  ( RPMVSF_NOSHA1HEADER |       \
+    RPMVSF_NOMD5HEADER |        \
+    RPMVSF_NOSHA1 |             \
+    RPMVSF_NOMD5 )
+
+#define _RPMVSF_NOSIGNATURES    \
+  ( RPMVSF_NODSAHEADER |        \
+    RPMVSF_NORSAHEADER |        \
+    RPMVSF_NODSA |              \
+    RPMVSF_NORSA )
+#include <rpmrc.h>
+
+#else	/* RPM5 */
+
 #include <rpm/rpmts.h>
 #include <rpm/rpmfi.h>
 #include <rpm/rpmlib.h>
 #include <rpm/rpmmacro.h>
 #include <rpm/rpmkeyring.h>
-#include "error.h"
-#include "parsehdr.h"
+#endif	/* RPM5 */
+
 #include "parsepkg.h"
 #include "misc.h"
 #include "checksum.h"
diff --git a/src/sqlite.c b/src/sqlite.c
index 597c592..b669881 100644
--- a/src/sqlite.c
+++ b/src/sqlite.c
@@ -22,6 +22,8 @@
  * USA.
  */
 
+#include <sys/stat.h>
+
 #include <glib.h>
 #include <assert.h>
 #include <string.h>
-- 
2.9.3

